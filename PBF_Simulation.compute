#pragma kernel Pre_solve
#pragma kernel Calculate_lambda
#pragma kernel Calculate_delta_p
#pragma kernel Update_constrain_pos
#pragma kernel Post_solve
#pragma kernel Calculate_haptic_density
#pragma kernel Calculate_f_pressure
#pragma kernel Calculate_f_viscosity
#pragma kernel Apply_f_pressure
#pragma kernel Histogram
#pragma kernel Scatter
#pragma kernel UpdateDensityTexture
#pragma kernel FindNeighborList

#define THREAD_GROUP_SIZE_X 256
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 1
#define h 1.0f
#define h_3 (h * h * h)
#define h_6 (h_3 * h_3)
#define h_9 (h_6 * h_3)
#define PI 3.14159
#define poly6Coefficient (315.0f / (64.0f * PI * h_9))
#define spikeCoefficient (-45.0f / (PI * h_6))
struct particle
{
    float3 velocity;
    float lambda;
    float3 position;
    int flag;
    float3 acceleration;
    float density;
    float3 prePosition;
    int padding;
    float3 delta_p;
    int padding2;
};
struct MeshProperties
{
    float4x4 mat;
    float4 color;
};

RWStructuredBuffer<particle> particles;
RWStructuredBuffer<particle> unsortedParticles;
RWStructuredBuffer<MeshProperties> transformation;
RWStructuredBuffer<int> globalHistogram;
RWStructuredBuffer<int> neighborList;
//RWStructuredBuffer<int> globalHistogramPrefixSum;
RWStructuredBuffer<float3> hapticOutputForce;
//just for scan input buffer
RWStructuredBuffer<int> scanInput;
RWStructuredBuffer<int> scanBlockSum;
float3 hapticIntPutForce;
float deltaTime;
float inverseRestDensity;
int population;
//bin infos
int min_x, max_x;
int min_y, max_y;
int min_z, max_z;
int num_bin_x;
int num_bin_y;
int num_bin_z;
int MAX_NUM_NEIGHBOR;

RWTexture3D<float> DensityMap;
float3 densityMapSize;

int numOfParticles;
float3 hapticInteractionPoint;
float hapticInteractionPointDensity;
float3 hapticInVelocity;

float spacing;
groupshared int force_x;
groupshared int sharedArrayScan[THREAD_GROUP_SIZE_X * 2];

int find_bin(float3 p)
{
    int x = clamp(int((p.x - min_x) / spacing), 0, num_bin_x - 1);
    int y = clamp(int((p.y - min_y) / spacing), 0, num_bin_y - 1);
    int z = clamp(int((p.z - min_z) / spacing), 0, num_bin_z - 1);

    return num_bin_x * num_bin_y * z + num_bin_x * y + x;
}
float Poly6Kernel(float3 p)
{
    float d = h * h - dot(p, p);
    if (d < 0)
        return 0.0f;
    else
    {
        return poly6Coefficient * d * d * d;
    }
}
float Scorr(float3 p)
{
    float upper = Poly6Kernel(p);
    float3 v = 0.1 * h * float3(1, 0, 0);
    float low = Poly6Kernel(v);
    float m = upper / low;
    return -1 * m * m * m * m;
}
float3 SpikeKernelGradient(float3 p)
{
    float d = h - length(p);
    if (d < 0 || length(p) == 0)
        return float3(0.0f,0.0f,0.0f);
    else
    {
        return (spikeCoefficient * d * d) / (length(p)) * normalize(p);
    }

}
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Pre_solve(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    particles[global_index].prePosition = particles[global_index].position;
    particles[global_index].velocity += particles[global_index].acceleration * deltaTime;
    particles[global_index].position += particles[global_index].velocity * deltaTime;
    particles[global_index].acceleration = float3(0,-10.0f,0);
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Histogram(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    int binIndex = find_bin(unsortedParticles[global_index].position);
    InterlockedAdd(globalHistogram[binIndex], 1, unsortedParticles[global_index].flag);
    unsortedParticles[global_index].padding = binIndex;
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Scatter(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    int binIndex = find_bin(unsortedParticles[global_index].position);
    
    uint globalStartIndex = globalHistogram[binIndex];
    
    particles[globalStartIndex + unsortedParticles[global_index].flag] = unsortedParticles[global_index];
    //check if sorted
    //particles[globalStartIndex + unsortedParticles[global_index].flag].flag = globalStartIndex + unsortedParticles[global_index].flag;
    //unsortedParticles[global_index].flag = particles[globalStartIndex + unsortedParticles[global_index].flag].flag;
}
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void FindNeighborList(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    int globalStartIndex = global_index * MAX_NUM_NEIGHBOR;
    int counter = 0;
    //neighborList
    for (int i = 0; i < MAX_NUM_NEIGHBOR; i++)
    {
        neighborList[globalStartIndex + i] = 0;

    }
    
    int3 binIndexMin = clamp(particles[global_index].position - float3(spacing, spacing, spacing), int3(min_x, min_y, min_z), int3(max_x - 1, max_y - 1, max_z - 1));
    int3 binIndexMax = clamp(particles[global_index].position + float3(spacing, spacing, spacing), int3(min_x, min_y, min_z), int3(max_x - 1, max_y - 1, max_z - 1));
    
    for (int k = binIndexMin.z; k <= binIndexMax.z; k++)
    {
        for (int j = binIndexMin.y; j <= binIndexMax.y; j++)
        {
            for (int i = binIndexMin.x; i <= binIndexMax.x; i++)
            {
                int binIndex = num_bin_x * num_bin_y * k + num_bin_x * j + i;
                int start = globalHistogram[binIndex];
                int end = globalHistogram[binIndex + 1];
                
                for (int p = start; p < end; p++)
                {
                    if (p == global_index)
                        continue;
                    float3 v = particles[global_index].position - particles[p].position;
                    if (dot(v, v) <= 1.0f)
                    {
                        neighborList[globalStartIndex + counter] = p;
                        counter++;
                        if (counter == MAX_NUM_NEIGHBOR - 1)
                        {
                            particles[global_index].padding2 = counter;
                            return;
                        }
                    }
                }
            }

        }
    }
    if (counter < MAX_NUM_NEIGHBOR - 1)
        neighborList[globalStartIndex + counter] = -1;
    
    particles[global_index].padding2 = counter;
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Calculate_lambda(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    float density = 0.0f;
    float w = 0.0f;
    float3 gradient = float3(0.0f, 0.0f, 0.0f);
    
    //particles[global_index].padding2 = 0;
    
    int3 binIndexMin = clamp(particles[global_index].position - float3(spacing, spacing, spacing), int3(min_x, min_y, min_z), int3(max_x - 1, max_y - 1, max_z - 1));
    int3 binIndexMax = clamp(particles[global_index].position + float3(spacing, spacing, spacing), int3(min_x, min_y, min_z), int3(max_x - 1, max_y - 1, max_z - 1));
    
    for (int k = binIndexMin.z; k <= binIndexMax.z; k++)
    {
        for (int j = binIndexMin.y; j <= binIndexMax.y; j++)
        {
            for (int i = binIndexMin.x; i <= binIndexMax.x; i++)
            {
                int binIndex = num_bin_x * num_bin_y * k + num_bin_x * j + i;
                int start = globalHistogram[binIndex];
                int end = globalHistogram[binIndex + 1];
                
                for (int p = start; p < end; p++)
                {
                    float3 v = particles[global_index].position - particles[p].position;
                    if (dot(v, v) <= 1.0f)
                    {
                        density += Poly6Kernel(v);
                        float3 tmp = SpikeKernelGradient(v);
                        gradient -= tmp * inverseRestDensity;
                        w += inverseRestDensity * inverseRestDensity * dot(tmp, tmp);
                        //particles[global_index].padding2++;

                    }
                }
                
            }

        }

    }
    /*
    
    int startIndex = global_index * MAX_NUM_NEIGHBOR;
    for (int i = startIndex; i < startIndex + MAX_NUM_NEIGHBOR;i++)
    {
        if (neighborList[i]==-1)
            break;
        float3 v = particles[global_index].position - particles[neighborList[i]].position;
        
        density += Poly6Kernel(v);
        float3 tmp = SpikeKernelGradient(v);
        gradient -= tmp * inverseRestDensity;
        w += inverseRestDensity * inverseRestDensity * dot(tmp, tmp);

    }
    */
    
    gradient *= inverseRestDensity;
    float C = density * inverseRestDensity - 1.0f;
    float lambda = -C / (w + dot(gradient, gradient) + 200);
    
    particles[global_index].lambda = C;
    particles[global_index].density = density;
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Calculate_delta_p(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    float3 delta_p = float3(0.0f, 0.0f, 0.0f);
    
    int3 binIndexMin = clamp(particles[global_index].position - float3(spacing, spacing, spacing), int3(min_x, min_y, min_z), int3(max_x - 1, max_y - 1, max_z - 1));
    int3 binIndexMax = clamp(particles[global_index].position + float3(spacing, spacing, spacing), int3(min_x, min_y, min_z), int3(max_x - 1, max_y - 1, max_z - 1));
    
    for (int k = binIndexMin.z; k <= binIndexMax.z; k++)
    {
        for (int j = binIndexMin.y; j <= binIndexMax.y; j++)
        {
            for (int i = binIndexMin.x; i <= binIndexMax.x; i++)
            {
                int binIndex = num_bin_x * num_bin_y * k + num_bin_x * j + i;
                int start = globalHistogram[binIndex];
                int end = globalHistogram[binIndex + 1];
                
                for (int p = start; p < end; p++)
                {
                    float3 v = particles[global_index].position - particles[p].position;
                    if (dot(v, v) <= 1.0f)
                    {
                        float s_corr = Scorr(v);
                        float3 gradient = SpikeKernelGradient(v);
                        delta_p += inverseRestDensity * (particles[p].lambda + particles[global_index].lambda + s_corr) * gradient;
                    }
                }
                
            }

        }

    }
    
    /*
    int startIndex = global_index * MAX_NUM_NEIGHBOR;
    for (int i = startIndex; i < startIndex + MAX_NUM_NEIGHBOR; i++)
    {
        if (neighborList[i] == -1)
            break;
        float3 v = particles[global_index].position - particles[neighborList[i]].position;
        float s_corr = Scorr(v);
        float3 gradient = SpikeKernelGradient(v);
        delta_p += inverseRestDensity * (particles[neighborList[i]].lambda + particles[global_index].lambda + s_corr) * gradient;
    }
    */
    //particles[global_index].padding == 0;
    
    float3 pos = particles[global_index].position + delta_p;
    
    float force = 1.0f;
    
    float3 boundariesMin = float3(min_x, min_y, min_z);
    float3 boundariesMax = float3(max_x, max_y, max_z);
    
    float3 d_min = boundariesMin - pos; // If pos < lower bound, d_min > 0.
    float3 d_max = pos - boundariesMax; // If pos > upper bound, d_max > 0.

    float3 correction = max(d_min, 0.0) - max(d_max, 0.0);

    pos += correction;

    float3 accelCorrection = force * (step(0.0, d_min) - step(0.0, d_max));
    
    particles[global_index].acceleration += accelCorrection;
    /*
    if (dot(pos - float3(min_x, 0, 0), float3(1, 0, 0)) < 0)
    {
        pos -= dot(pos - float3(min_x, 0, 0), float3(1, 0, 0)) * float3(1, 0, 0);
        particles[global_index].acceleration.x += force;
    }
    
    if (dot(pos - float3(max_x, 0, 0), float3(-1, 0, 0)) < 0)
    {
        pos -= dot(pos - float3(max_x, 0, 0), float3(-1, 0, 0)) * float3(-1, 0, 0);
        particles[global_index].acceleration.x -= force;
    }
    
    if (dot(pos - float3(0, min_y, 0), float3(0, 1, 0)) < 0)
    {
        pos -= dot(pos - float3(0, min_y, 0), float3(0, 1, 0)) * float3(0, 1, 0);
        particles[global_index].acceleration.y += force;
    }
    
    if (dot(pos - float3(0, max_y, 0), float3(0, -1, 0)) < 0)
    {
        pos -= dot(pos - float3(0, max_y, 0), float3(0, -1, 0)) * float3(0, -1, 0);
        particles[global_index].acceleration.y -= force;
    }
    
    if (dot(pos - float3(0, 0, min_z), float3(0, 0, 1)) < 0)
    {
        pos -= dot(pos - float3(0, 0, min_z), float3(0, 0, 1)) * float3(0, 0, 1);
        particles[global_index].acceleration.z += force;
    }
    
    if (dot(pos - float3(0, 0, max_z), float3(0, 0, -1)) < 0)
    {
        pos -= dot(pos - float3(0, 0, max_z), float3(0, 0, -1)) * float3(0, 0, -1);
        particles[global_index].acceleration.z -= force;
    }
    */
    //pos.x = clamp(pos.x, min_x, max_x);
    //pos.y = clamp(pos.y, min_y, max_y);
    //pos.z = clamp(pos.z, min_z, max_z);
    
    particles[global_index].delta_p = pos - particles[global_index].position;
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Update_constrain_pos(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    float3 pos = particles[global_index].position + particles[global_index].delta_p;
    particles[global_index].position = pos;
    
    int renderFlag = 0;
    float offset = 0.2;
    
    renderFlag = (pos.x > max_x - offset) || (pos.x < min_x + offset) || (pos.y < min_y) || (pos.z < min_z + offset) || (pos.z > max_z - offset);
    
    
    //particles[global_index].padding = renderFlag;
}
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Post_solve(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    
    float3 v = 1.0 * (particles[global_index].position - particles[global_index].prePosition) / deltaTime;
    float speed = length(v);
    if(speed > 5.0f)
        v = 5.0f * normalize(v);
    
    particles[global_index].velocity = v;
    
    unsortedParticles[global_index] = particles[global_index];
    
    transformation[global_index].mat[0][3] = particles[global_index].position[0];
    transformation[global_index].mat[1][3] = particles[global_index].position[1];
    transformation[global_index].mat[2][3] = particles[global_index].position[2];
    //reset to 0
    //globalHistogramPrefixSum[global_index] = 0;
}
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Calculate_haptic_density(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    float hapticDensity = 0.0f;

    hapticOutputForce[global_index] = float3(0, 0, 0);

    float3 v = particles[global_index].position - hapticInteractionPoint;

    if (dot(v, v) <= 1.0f)
    {
        hapticDensity += Poly6Kernel(v);
    }

    hapticOutputForce[global_index].x = hapticDensity;

}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Calculate_f_pressure(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    
    hapticOutputForce[global_index] = float3(0, 0, 0);
    
    float3 pressure_force = float3(0,0,0);
    
    float3 v = particles[global_index].position - hapticInteractionPoint;
    
    float k = 0.0004;
    float restDensity = 15.0f;

    //hapticInteractionPointDensity = clamp(hapticInteractionPointDensity, 7.0f , 20.0f);

    float P = k * (hapticInteractionPointDensity - restDensity);
    ////calculate the output force
    if (dot(v, v) <= 1.0f)
    {
        //hapticOutputForce[0] += 0.4 * v;//particles[global_index].position;
        float P_i = k * (particles[global_index].density - restDensity);
        pressure_force -= 0.5f * (P_i + P) * SpikeKernelGradient(v);
    }
    
    hapticOutputForce[global_index] = pressure_force;

}


[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Calculate_f_viscosity(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    float3 viscosity_force = float3(0, 0, 0);
    
    float3 v = particles[global_index].position - hapticInteractionPoint;
    
    float k = 0.1;
    ////calculate the output force
    if (dot(v, v) <= 1.0f)
    {
        //hapticOutputForce[0] += 0.4 * v;//particles[global_index].position;
        float P_i = k * (particles[global_index].density - 1.0 / inverseRestDensity);
        viscosity_force -= 0.5f * (P_i + hapticInteractionPointDensity) * SpikeKernelGradient(v);
    }
    
    hapticOutputForce[global_index] = viscosity_force;

}
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void Apply_f_pressure(uint3 id : SV_DispatchThreadID)
{
    uint global_index = id.x;
    if (global_index >= numOfParticles)
        return;
    float3 v = particles[global_index].position - hapticInteractionPoint;
    particles[global_index].acceleration += 5 * (dot(v, v) <= 1.0f) * hapticIntPutForce + (dot(v, v) > 1.0f) * float3(0, -10, 0);
    
    globalHistogram[global_index] = 0;
}


[numthreads(8, 8, 8)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= densityMapSize.x || id.y >= densityMapSize.y || id.z >= densityMapSize.z)
        return;

    float3 texturePos = (float3) id / (densityMapSize - 1.0);
    //float3 worldPos = (texturePos - 0.5) * boundsSize;
    float3 worldPos = texturePos * float3(max_x - min_x, max_y - min_y, max_z - min_z);
    
    //DensityMap[id] = CalculateDensitiesAtPoint(worldPos)[0];
    
    float density = 0;
    
    int binIndex = find_bin(worldPos);
    
    int binIndexMinX = clamp((worldPos - float3(spacing, 0, 0)).x / spacing, min_x, max_x - 1);
    int binIndexMaxX = clamp((worldPos + float3(spacing, 0, 0)).x / spacing, min_x, max_x - 1);
    
    int binIndexMinY = clamp((worldPos - float3(0, spacing, 0)).y / spacing, min_y, max_y - 1);
    int binIndexMaxY = clamp((worldPos + float3(0, spacing, 0)).y / spacing, min_y, max_y - 1);
    
    int binIndexMinZ = clamp((worldPos - float3(0, 0, spacing)).z / spacing, min_z, max_z - 1);
    int binIndexMaxZ = clamp((worldPos + float3(0, 0, spacing)).z / spacing, min_z, max_z - 1);
    
    for (int k = binIndexMinZ; k <= binIndexMaxZ; k++)
    {
        for (int j = binIndexMinY; j <= binIndexMaxY; j++)
        {
            for (int i = binIndexMinX; i <= binIndexMaxX; i++)
            {
                int binIndex = num_bin_x * num_bin_y * k + num_bin_x * j + i;
                int start = globalHistogram[binIndex];
                int end = globalHistogram[binIndex + 1];
                
                for (int p = start; p < end; p++)
                {
                    float3 v = worldPos - particles[p].position;
                    density += (dot(v, v) <= 1.0f) * particles[p].density;
                }
                
            }

        }

    }
    
    DensityMap[id] = density;
}